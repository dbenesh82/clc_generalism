---
title: "Simulate parasites in webs"
author: "Dan Benesh"
date: "12/19/2019"
output: html_document
---

In this notebook, I quantify how parasites with longer life cycles may accumulate hosts. To do this, I used a compilation of food webs.

```{r setup, include=FALSE}
library(ggplot2)
library(dplyr)
library(tidyr)
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE)
options(stringsAsFactors = FALSE)
theme_set(new = theme_bw())
```

```{r}
brose19 <- read.csv(file = "../../../Mapping_LCL/host_similarity_clustering/data/host_mass/283_2_FoodWebDataBase_2018_12_10.csv")
```
```{r}
# sort(unique( paste(brose19$link.citation, ":" , brose19$foodweb.name)))
```

I exclude parasitic links from the food web compilation, leaving mainly herbivory and predation links.

```{r}
brose19 <- filter(brose19, interaction.type != 'parasitic', interaction.type != 'parasitoid')%>%
  select(autoID, con.taxonomy, con.taxonomy.level, con.lifestage, con.mass.mean.g.,
         res.taxonomy, res.taxonomy.level, res.lifestage, res.mass.mean.g., 
         foodweb.name, web_study = link.citation)
```
```{r}
# head(brose19)
```

I also include some additional food webs with parasites.

```{r}
# Otago
otago_links <- read.csv("../../data/webs/Otago_Data_Links.csv")
otago_nodes <- read.csv("../../data/webs/Otago_Data_Nodes.csv")

otago_links <- filter(otago_links, LinkType == "Predation")
otago_links <- left_join(otago_links, select(otago_nodes, NodeID, con.taxonomy = WorkingName, con.taxonomy.level = Resolution, con.lifestage = Stage),
                         by = c("ConsumerNodeID" = "NodeID"))
otago_links <- left_join(otago_links, select(otago_nodes, NodeID, res.taxonomy = WorkingName, res.taxonomy.level = Resolution, res.lifestage = Stage),
                         by = c("ResourceNodeID" = "NodeID"))
otago_links <- select(otago_links, con.taxonomy, con.taxonomy.level, con.lifestage, res.taxonomy, res.taxonomy.level, res.lifestage)
otago_links$foodweb.name <- "Otago"
otago_links$web_study <- "Mouritsen et al. (2011)"
```
```{r}
# Sylt
sylt_links <- read.csv("../../data/webs/ECOL_92_172/Sylt_Data_Links.csv")
sylt_nodes <- read.csv("../../data/webs/ECOL_92_172/Sylt_Data_Nodes.csv")

sylt_links <- filter(sylt_links, LinkType == "Predation")
sylt_links <- left_join(sylt_links, select(sylt_nodes, NodeID, con.taxonomy = WorkingName, con.taxonomy.level = Resolution, con.lifestage = Stage),
                         by = c("ConsumerNodeID" = "NodeID"))
sylt_links <- left_join(sylt_links, select(sylt_nodes, NodeID, res.taxonomy = WorkingName, res.taxonomy.level = Resolution, res.lifestage = Stage),
                         by = c("ResourceNodeID" = "NodeID"))
sylt_links <- select(sylt_links, con.taxonomy, con.taxonomy.level, con.lifestage, res.taxonomy, res.taxonomy.level, res.lifestage)
sylt_links$foodweb.name <- "Sylt"
sylt_links$web_study <- "Thieltges et al. (2011)"
```
```{r}
# Flensburg
flens_links <- read.csv("../../data/webs/ECOL_92_174/Flensburg_Data_Links.csv")
flens_nodes <- read.csv("../../data/webs/ECOL_92_174/Flensburg_Data_Nodes.csv")

flens_links <- filter(flens_links, LinkType == "Predation" | LinkType == "Detritivory")
flens_links <- left_join(flens_links, select(flens_nodes, Node.ID, con.taxonomy = WorkingName, con.taxonomy.level = Resolution, con.lifestage = Stage),
                         by = c("ConsumerNodeID" = "Node.ID"))
flens_links <- left_join(flens_links, select(flens_nodes, Node.ID, res.taxonomy = WorkingName, res.taxonomy.level = Resolution, res.lifestage = Stage),
                         by = c("ResourceNodeID" = "Node.ID"))
flens_links <- select(flens_links, con.taxonomy, con.taxonomy.level, con.lifestage, res.taxonomy, res.taxonomy.level, res.lifestage)
flens_links$foodweb.name <- "Flensburg"
flens_links$web_study <- "Zander et al. (2011)"
```
```{r}
# Quick pond
qp_links <- read.csv("../../data/webs/ECOL_93_153/Data/Quick_Pond_Links.csv")
qp_nodes <- read.csv("../../data/webs/ECOL_93_153/Data/Quick_Pond_Nodes.csv")

qp_links <- filter(qp_links, LinkType == "predation" | LinkType == "detritivory")
qp_links <- left_join(qp_links, select(qp_nodes, NodeID, con.taxonomy = WorkingName, con.taxonomy.level = Resolution, con.lifestage = Stage),
                         by = c("ConsumerNodeID" = "NodeID"))
qp_links <- left_join(qp_links, select(qp_nodes, NodeID, res.taxonomy = WorkingName, res.taxonomy.level = Resolution, res.lifestage = Stage),
                         by = c("ResourceNodeID" = "NodeID"))
qp_links <- select(qp_links, con.taxonomy, con.taxonomy.level, con.lifestage, res.taxonomy, res.taxonomy.level, res.lifestage)
qp_links$foodweb.name <- "Quick Pond"
qp_links$web_study <- "Preston et al. (2012)"
```
```{r}
# Baja
bsq_links <- read.table("../../data/webs/ECOL_92_66/BSQweb_Links.txt", header = T, sep = "\t")
bsq_nodes <- read.csv("../../data/webs/ECOL_92_66/BSQ_nodes.csv")

bsq_links <- filter(bsq_links, LinkType == "predation" | LinkType == "detritivory")
bsq_links <- left_join(bsq_links, select(bsq_nodes, NodeID, con.taxonomy = WorkingName, con.taxonomy.level = Resolution, con.lifestage = Stage),
                         by = c("ConsumerNodeID" = "NodeID"))
bsq_links <- left_join(bsq_links, select(bsq_nodes, NodeID, res.taxonomy = WorkingName, res.taxonomy.level = Resolution, res.lifestage = Stage),
                         by = c("ResourceNodeID" = "NodeID"))
bsq_links <- select(bsq_links, con.taxonomy, con.taxonomy.level, con.lifestage, res.taxonomy, res.taxonomy.level, res.lifestage)
bsq_links$foodweb.name <- "Bahía San Quintín"
bsq_links$web_study <- "Hechinger et al. (2011)"
```
```{r}
# Estero
epb_links <- read.table("../../data/webs/ECOL_92_66/EPBweb_Links.txt", header = T, sep = "\t")
epb_nodes <- read.csv("../../data/webs/ECOL_92_66/EPB_nodes.csv")

epb_links <- filter(epb_links, LinkType == "predation" | LinkType == "detritivory")
epb_links <- left_join(epb_links, select(epb_nodes, NodeID, con.taxonomy = WorkingName, con.taxonomy.level = Resolution, con.lifestage = Stage),
                         by = c("ConsumerNodeID" = "NodeID"))
epb_links <- left_join(epb_links, select(epb_nodes, NodeID, res.taxonomy = WorkingName, res.taxonomy.level = Resolution, res.lifestage = Stage),
                         by = c("ResourceNodeID" = "NodeID"))
epb_links <- select(epb_links, con.taxonomy, con.taxonomy.level, con.lifestage, res.taxonomy, res.taxonomy.level, res.lifestage)
epb_links$foodweb.name <- "Estero de Punta Banda"
epb_links$web_study <- "Hechinger et al. (2011)"
```
```{r}
paras_fws <- bind_rows(otago_links, sylt_links, flens_links, qp_links, bsq_links, epb_links)
rm(otago_links, sylt_links, qp_links, bsq_links, epb_links, flens_links,
   otago_nodes, sylt_nodes, qp_nodes, bsq_nodes, epb_nodes, flens_nodes)
paras_fws$autoID <- seq(from = max(brose19$autoID, na.rm=T)+1, to = max(brose19$autoID, na.rm=T) + length(paras_fws$con.taxonomy), by = 1)
```

```{r}
brose19 <- bind_rows(brose19, paras_fws)
```
```{r}
brose19 <- mutate(brose19, con.taxonomy.level = tolower(con.taxonomy.level))
brose19$con.taxonomy.level[which(brose19$con.taxonomy.level == "genus ")] <- 'genus'
brose19$con.taxonomy.level[which(brose19$con.taxonomy.level == "infraorder")] <- 'order'
```

There are this many consumer-resource links in the compilation: 

```{r}
length(brose19$autoID)
```

From this many foodwebs:

```{r}
n_distinct(brose19$foodweb.name)
```

For every link, I calculated the minimum number of steps until reaching a basal resource in the food web. A basal resource was one that was in the web only as resource not as a consumer.

```{r}
fws_arr <- group_by(brose19, foodweb.name)%>%
  summarize(n = n())%>%
  arrange(desc(n))
```
```{r}
brose19TL <- brose19
brose19TL$TL <- NA
fws <- fws_arr$foodweb.name
for(fw in fws){
  # print(fw)
  # loop through food webs
  fw_ds <- filter(brose19, foodweb.name == fw) # data for food web
  basal_spp <- unique(fw_ds$res.taxonomy)[!unique(fw_ds$res.taxonomy) %in% fw_ds$con.taxonomy] # basal spp in food web
  
  # for each food web, loop through links
  for(i in seq_along(fw_ds$con.taxonomy)){
    tl <- 2
    lk <- fw_ds[i,]
    res <- lk$res.taxonomy
    while(sum(res %in% basal_spp)==0){ # add tl until reach basal spp
      tl <- tl + 1
      res <- filter(fw_ds, con.taxonomy %in% res)$res.taxonomy
      if(tl > 8){ # if TL gets too high, you're in a loop, break out
        tl <- NA
        break
      } 
    }
    fw_ds$TL[i] <- tl
  }
  
  mv <- match(brose19TL$autoID, fw_ds$autoID)
  brose19TL$TL[which(!is.na(mv))] <- fw_ds$TL[na.omit(mv)]
}
```

For every consumer in each food web, I averaged across prey items to get an average trophic level estimate (this assumes that prey are consumed equally). I also calculated a short-weighted version of trophic level by averaging a consumer's mean and minimum trophic level. Finally, I also calculated diet breadth and vulnerability for every consumer.

```{r}
brose19TL <- group_by(brose19TL, con.taxonomy, foodweb.name)%>%
  summarize(avg_TL = mean(TL, na.rm = T), min_TL = min(TL, na.rm = T),
            diet_breath = length(unique(res.taxonomy)),
            bm = mean(con.mass.mean.g., na.rm = T))%>%
  mutate(sw_TL = (avg_TL + min_TL)/2)
```
```{r}
brose19TL$avg_TLcat <- cut(brose19TL$avg_TL, breaks = c(2, 2.5, 3, 3.5, 4, 4.5), include.lowest = T)
```
```{r}
brose19TL2 <- group_by(brose19, res.taxonomy, foodweb.name)%>% # group by resource, calculate vulnerability
  summarize(vulnerability = length(unique(con.taxonomy)))
brose19TL <- left_join(brose19TL, select(brose19TL2, con.taxonomy = res.taxonomy, foodweb.name, vulnerability)) # combine with consumer-based table
rm(brose19TL2)
```
```{r}
# add a resolution variable to main dataset
res_var <- select(brose19, con.taxonomy, con.taxonomy.level, foodweb.name)%>%distinct()
brose19TL <- left_join(brose19TL, res_var)
brose19TL <- mutate(brose19TL, con.taxonomy.level = factor(con.taxonomy.level, levels = c('species', 'genus', 'family', 'order', 'class', 'assemblage')))
```
```{r}
brose19TL <- left_join(brose19TL, select(brose19, foodweb.name, web_study)%>%distinct()) # add web study var to TL dataframe
```
```{r}
add_study <- select(brose19, foodweb.name, web_study)%>%distinct()
brose19TL <- left_join(brose19TL, add_study)
brose19TL <- mutate(brose19TL, avg_TLcen = avg_TL - 2)
```

```{r}
webs_with_verts <- c("Cattin Blandenier (2004)", "Cohen et al. (2009)", "Ekloef et al. (2013)", "Gray et al. (2015), Thompson et al. (2017)",
                        "Jacob et al. (2011)", "Jacob et al. (2015)", "Jonsson et al. (2005)", "Kefi et al. (2015)", "Kroll, unpublished ",
                        "Lafferty et al. (2006)", "Layer et al. (2010)", "Legagneux et al. (2014)", "Mendonca et al. (2018)", "Nsiku (1999)",
                        "O'Gorman et al. (2012)", "Opitz (1996)", "Sutherland (1989), Havens (1992)", "Townsend et al. (1998)", 
                     "Mouritsen et al. (2011)", "Thieltges et al. (2011)","Zander et al. (2011)", "Preston et al. (2012)","Hechinger et al. (2011)")

most_relevant_studies <- c("Cattin Blandenier (2004)", "Cohen et al. (2009)", "Ekloef et al. (2013)", 
                        "Jacob et al. (2011)", "Jacob et al. (2015)", "Kroll, unpublished ",
                        "Lafferty et al. (2006)", "Legagneux et al. (2014)", "Opitz (1996)", "Sutherland (1989), Havens (1992)",
                        "Mouritsen et al. (2011)", "Thieltges et al. (2011)", "Zander et al. (2011)", "Preston et al. (2012)", "Hechinger et al. (2011)")
most_relevant_studies2 <- c("Cohen et al. (2009)", "Ekloef et al. (2013)", 
                        "Jacob et al. (2011)", "Jacob et al. (2015)", "Lafferty et al. (2006)", 
                        "Mouritsen et al. (2011)", "Thieltges et al. (2011)", "Preston et al. (2012)", "Hechinger et al. (2011)") #"Zander et al. (2011)"

```

I also want to examine how taxonomic diversity varies through food webs. For that, I downloaded taxonomic info for the species in the food webs and added it to the food web data.

```{r}
# load host taxonomy
host.tax <- read.csv(file = "../../../Mapping_LCL/host_similarity_clustering/data/ncbi_host_taxonomy_body_size_dat.csv")
```
```{r}
# some host taxonomy was missing for ~180 spp in LCDB, so I manually filled it
not_ncbi_tax <- read.csv(file = "../../../Mapping_LCL/host_similarity_clustering/data/host_tax_manually_filled.csv", header = TRUE)
# also re-ran taxonomy script for FW data
host.tax.fw <- read.csv(file = "../../data/ncbi_host_taxonomy_FW.csv", header = T)
# make a single host tax ds
host.tax2 <- select(host.tax, sp.query, genus, family, order, class, phylum)
host.tax2 <- bind_rows(host.tax2, select(not_ncbi_tax, sp.query = binomial, genus, family, order, class, phylum))%>%distinct()
host.tax2 <- bind_rows(host.tax2, select(host.tax.fw, sp.query, genus, family, order, class, phylum))%>%distinct()
# make host genus lowercase, better matching?
host.tax2 <- mutate(host.tax2, g2 = tolower(genus))
```
```{r}
brose19 <- mutate(brose19, genus = substr(con.taxonomy, start = 1, stop = regexpr(" ", con.taxonomy) - 1))%>%
  mutate(genus = if_else(con.taxonomy.level == "genus" & genus == "", con.taxonomy, genus))%>%
  mutate(g2 = tolower(genus))
```
```{r}
# food webs with worms
otago_nodes <- read.csv("../../data/webs/Otago_Data_Nodes.csv")
otago_nodes <- select(otago_nodes, WorkingName, genus = Genus, species = SpecificEpithet)%>%distinct()
sylt_nodes <- read.csv("../../data/webs/ECOL_92_172/Sylt_Data_Nodes.csv")
sylt_nodes <- select(sylt_nodes, WorkingName, genus = Genus, species = SpecificEpithet)%>%distinct()
flens_nodes <- read.csv("../../data/webs/ECOL_92_174/Flensburg_Data_Nodes.csv")
flens_nodes <- select(flens_nodes, WorkingName, genus = Genus, species = Specific.epithet)%>%distinct()
qp_nodes <- read.csv("../../data/webs/ECOL_93_153/Data/Quick_Pond_Nodes.csv")
qp_nodes <- select(qp_nodes, WorkingName, genus = Genus, species = SpecificEpithet)%>%distinct()
bsq_nodes <- read.csv("../../data/webs/ECOL_92_66/BSQ_nodes.csv")
bsq_nodes <- select(bsq_nodes, WorkingName, genus = Genus, species = SpecificEpithet)%>%distinct()
epb_nodes <- read.csv("../../data/webs/ECOL_92_66/EPB_nodes.csv")
epb_nodes <- select(epb_nodes, WorkingName, genus = Genus, species = SpecificEpithet)%>%distinct()
otago_nodes$foodweb.name <- "Otago"
sylt_nodes$foodweb.name <- "Sylt"
flens_nodes$foodweb.name <- "Flensburg"
qp_nodes$foodweb.name <- "Quick Pond"
bsq_nodes$foodweb.name <- "Bahía San Quintín"
epb_nodes$foodweb.name <- "Estero de Punta Banda"

ps_fw_spp <- bind_rows(otago_nodes, sylt_nodes, flens_nodes, qp_nodes, bsq_nodes, epb_nodes)

ps_fw_spp <- ps_fw_spp%>%distinct()%>%
  filter(genus != "")%>%
  mutate(con.taxonomy = paste(genus, species), g2 = tolower(genus))

ps_fw_spp$con.taxonomy.level <- "genus" # all are at least specified to genus
rm(otago_nodes, sylt_nodes, flens_nodes, qp_nodes, bsq_nodes, epb_nodes)
```
```{r}
mv <- match( paste(brose19$con.taxonomy, brose19$foodweb.name), 
             paste(ps_fw_spp$WorkingName, ps_fw_spp$foodweb.name))

brose19$g2[!is.na(mv)] <- ps_fw_spp$g2[na.omit(mv)]
```
```{r}
fw_tax <- left_join( filter(brose19, g2!= "", !is.na(g2)),
                    select(host.tax2, g2, family, order, class, phylum)%>%distinct(),
                    by = 'g2')
```

Not every consumer in the food webs had taxonomic information available. There are this many unique consumers in the data:

```{r}
n_distinct(brose19$con.taxonomy)
```

And this many lacked complete taxonomic information:

```{r}
mx <- select(fw_tax, con.taxonomy, genus, family, order, class, phylum)%>%
  distinct()

n_distinct(filter(mx, is.na(family)|is.na(order)|is.na(class)|is.na(phylum))$con.taxonomy)
```

Here's a random sample of consumers missing taxonomic data. They often have common names or are family names. For our purposes, we'll assume this taxonomic data is missing at random.

```{r}
filter(ungroup(mx), is.na(family))%>%
  sample_n(size = 20)
rm(mx)
```

```{r}
# restrict to just full tax data
fw_tax <- ungroup(fw_tax)%>%
  arrange(foodweb.name)%>%
  filter(!is.na(genus) , !is.na(family) , !is.na(order) , !is.na(class) , !is.na(phylum))%>%
  select(con.taxonomy, genus, family, order, class, phylum, foodweb.name, web_study)
```

# Potential host range expansion with sequential predation events

We have two opposing food web trends that should affect host range. First, generalism 'radiates' in that a parasite with more first hosts has more *potential* second hosts. Second, this radiation is constrained by a reduction in potential predators at higher trophic levels - there are fewer top predators than primary consumers. In previous analyses, I confirmed both these patterns separately, but struggled to combine them. I used the accumulation of species with trophic level as a proxy for how generalism should accumulate with longer life cycles. However, there are a couple critiques to this approach: (1) it primarily represents how potential host range increases due to food web structural constraints and says less about how 'generalism' radiates when unconstrained and (2) trophic level does not perfectly represent predation events (i.e. omnivory).

To avoid these problems, I took a different approach. Specifically, I put hypothetical parasites into the food webs in primary consumers (TL < 2.25), and then examined how the number of potential hosts changed with successive predation events. For example, if a parasite infects one first host, how many second hosts will it be ingested by? How many unique predators do those second hosts have, and so on? I varied the number of primary consumers (first host) the parasite could infect. I had parasites that could infect, say, 1, 2, 3 random primary consumers and so on up to the maximum number of primary consumers in the web. When a parasite infects few first hosts, the number of potential next hosts is determined by 'vulnerability', i.e. the number of predators of the current host(s). On the other hand, as the parasite infects more and more first hosts, the number of next hosts becomes constrained, because there are only so many available next host predators in the food web. This is the interaction depicted in Fig. XX created by Geoff and Jimmy. Importantly, I limited 'intraguild predation' as a transmission route in that if a host is part of a parasite's available hosts at a given stage, then it is not included in the potential hosts at the next stage. For example, host *a* and *b* can be reached through one predation event (second hosts), but host *b* also consumes host *a* (intraguild predation), then we would not consider host *b* in the group of next hosts (third hosts).

```{r, message=FALSE, warning=FALSE}
source("../calculate_specificity_index/host_specificity_index_calculation_functions.R") # function for calculating hsi
```
```{r}
# this function is used several times in the loop to calculate the tax dissim index
get_hsi_func <- function(df, sp_names){
  
  dxx <- filter(df, con.taxonomy %in% sp_names)%>%distinct() # take taxonomy for species inputted
  
  if(dim(dxx)[1] == 0){
    hsi <- NA
  } else {
    hs.out <- with(dxx, hs.index(con.taxonomy, genus, family, order, class, phylum)) # calc host spec index
    hsi <- hs.out[1]
  }
  
  return(hsi)
}
```

```{r}
# create empty dataframe to collect results
chains3 <- filter(brose19, foodweb.name == "blah")%>%
  select(fw = foodweb.name, first_hosts = con.mass.mean.g.)%>% 
  mutate(first_hosts = as.integer(first_hosts), second_hosts = as.integer(first_hosts),
         third_hosts = as.integer(first_hosts), fourth_hosts = as.integer(first_hosts),
         tot_unique_hosts = as.integer(first_hosts),
         
         first_host_hsi = first_hosts, second_host_hsi = first_hosts,
         third_host_hsi = first_hosts, fourth_host_hsi = first_hosts,
         
         cum_first_host_hsi = first_hosts, cum_second_host_hsi = first_hosts,
         cum_third_host_hsi = first_hosts, cum_fourth_host_hsi = first_hosts,
         tot_hsi = first_hosts)

for(z in 1:25){ # loop through webs 3 times as test
  cat("Iteration:", as.character(z), "\n")

for(fw in fws){
  # print(fw)
  # loop through food webs
  fw_ds <- filter(brose19, foodweb.name == fw) # data for food web
  basal_spp <- unique(fw_ds$res.taxonomy)[!unique(fw_ds$res.taxonomy) %in% fw_ds$con.taxonomy] # basal spp in food web
  low_lev_cons <- filter(brose19TL, foodweb.name == fw, sw_TL <= 2.25)$con.taxonomy # take all consumers in web that get >75% of E from primary producers
  num_low_lev_cons <- length(low_lev_cons)
  
  fw_tax_hsi <- filter(fw_tax, foodweb.name == fw)
  
  # loop through different numbers of consumers
  for(c in 1:num_low_lev_cons){
    
    # host range
    first_hosts <- c
    start_consumers <- sample(low_lev_cons, size = c) # sample given number of consumers
    hosts <- start_consumers # start host list, this is for getting total number of unique hosts
    
    # tax dissim
    first_host_hsi <- get_hsi_func(fw_tax_hsi, start_consumers)
    cum_first_host_hsi <- first_host_hsi
    
    # take 3 steps up the food web from the base
    for(i in 1:3){
      
      # for each set of starting consumer, get their predators, exclude cannibalism
      ds <- filter(fw_ds, res.taxonomy %in% start_consumers, con.taxonomy != res.taxonomy)
      predators <- unique(ds$con.taxonomy) # can be overlap between predators and prey species, i.e. 'next hosts' are not filtered to be unique in the overall host set
      predators <- predators[!predators %in% hosts] # only take predators not in previous group of available hosts
      hosts <- unique(c(hosts, predators)) # update host list
      
      # calculate hsi for stage and cumulative (species) level
      hsi <- get_hsi_func(fw_tax_hsi, predators) # stage level tax dissim
      cum_hsi <- get_hsi_func(fw_tax_hsi, hosts) # species level tax dissim
 
      if(i == 1){
        second_hosts <- length(predators)
        second_host_hsi <- hsi
        cum_second_host_hsi <- cum_hsi
      } else if(i == 2) {
        third_hosts <- length(predators)
        third_host_hsi <- hsi
        cum_third_host_hsi <- cum_hsi
      } else {
        fourth_hosts <- length(predators)
        fourth_host_hsi <- hsi
        cum_fourth_host_hsi <- cum_hsi
      }
      # after recording number of potential next hosts, assign these predators to be starting consumers for next iteration
      start_consumers <- predators
      
    }
    
    # after taking steps up food web, calculate total host range, total host tax dissim
    tot_range <- length(hosts)
    tot_hsi <- get_hsi_func(fw_tax_hsi, hosts)
    # output it
    ds_out <- data.frame(fw = fw, first_hosts = first_hosts, second_hosts = second_hosts, 
                         third_hosts = third_hosts, fourth_hosts = fourth_hosts, tot_unique_hosts = tot_range,
                         first_host_hsi = first_host_hsi, second_host_hsi = second_host_hsi,
                         third_host_hsi = third_host_hsi, fourth_host_hsi = fourth_host_hsi,
                         cum_first_host_hsi = cum_first_host_hsi, cum_second_host_hsi = cum_second_host_hsi,
                         cum_third_host_hsi = cum_third_host_hsi, cum_fourth_host_hsi = cum_fourth_host_hsi,
                         tot_hsi = tot_hsi
                         )
    chains3 <- bind_rows(chains3, ds_out)
    chains3 <- distinct(chains3) # removes new row if already in out data frame, e.g. all first hosts infected
  }

}
}
```

```{r}
rm(dxx, ds_out, fw_ds, basal_spp, low_lev_cons, num_low_lev_cons, fw_tax_hsi, c, i,
   start_consumers, predators, mv, hs.out, fw,
   first_hosts, second_hosts, third_hosts, fourth_hosts, tot_range,
   first_host_hsi, second_host_hsi, third_host_hsi, fourth_host_hsi, hsi, tot_hsi,
   cum_first_host_hsi, cum_second_host_hsi, cum_third_host_hsi, cum_fourth_host_hsi, cum_hsi)
```

```{r}
chains3 <- mutate(chains3, index = 1:length(chains3$first_hosts))
```

```{r}
chains3_l <- chains3%>%
  select(fw:fourth_hosts, index)%>%
  gather(key = "steps", value = "hosts", first_hosts:fourth_hosts)%>%
  mutate(steps = factor(steps, levels = c("first_hosts", "second_hosts", "third_hosts", "fourth_hosts")))%>%
  group_by(fw, index)%>%
  arrange(fw, index)%>%
  mutate(cum_hosts = cumsum(hosts), step_int = as.integer(steps), step_intc = as.integer(steps)-1)
```
```{r}
chains3_l2 <- chains3%>%
  select(fw, index, first_host_hsi:fourth_host_hsi)%>%
  gather(key = "steps", value = "hsi", first_host_hsi:fourth_host_hsi)%>%
  mutate(steps = factor(steps,
                        levels = c("first_host_hsi", "second_host_hsi", "third_host_hsi", "fourth_host_hsi"),
                        labels = c("first_hosts", "second_hosts", "third_hosts", "fourth_hosts")))
chains3_l <- left_join(chains3_l, chains3_l2)
rm(chains3_l2)  
```
```{r}
chains3_l2 <- chains3%>%
  select(fw, index, cum_first_host_hsi:cum_fourth_host_hsi)%>%
  gather(key = "steps", value = "cum_hsi", cum_first_host_hsi:cum_fourth_host_hsi)%>%
  mutate(steps = factor(steps,
                        levels = c("cum_first_host_hsi", "cum_second_host_hsi", "cum_third_host_hsi", "cum_fourth_host_hsi"),
                        labels = c("first_hosts", "second_hosts", "third_hosts", "fourth_hosts")))
chains3_l <- left_join(chains3_l, chains3_l2)
rm(chains3_l2)  
```


```{r}
chains3_l <- left_join(chains3_l, select(ungroup(brose19TL), fw = foodweb.name, web_study)%>%distinct())
chains3_l <- left_join(chains3_l, select(chains3, index, first_hosts, tot_hosts = tot_unique_hosts, tot_hsi = tot_hsi))
chains3_l <- left_join(chains3_l, chains3%>%group_by(fw)%>%summarize(max_prim_consumers = max(first_hosts)))
# chains3_l <- left_join(chains3_l, chains3_l%>%group_by(fw, index)%>%summarize(tot_hosts = max(cum_hosts)))

```
```{r}
chains3_l <- mutate(chains3_l, prop_pot_first_hosts = first_hosts/max_prim_consumers)
chains3_l <- mutate(chains3_l, prop_hosts_per_stage = hosts/tot_hosts)
```

After creating this dataset of simulated parasite life cycles, I save the R env to file for use in another [notebook](quantifying_trans_opportunity_revised.Rmd).

```{r}
save.image(file = "dat_after_chains.RData")
```

